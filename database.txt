-- =============================================================================
-- Schéma de la base de données PostgreSQL pour l'application EVSCallPro
-- =============================================================================
-- Ce fichier définit la structure complète de la base de données, y compris
-- les types personnalisés, les tables, les relations, les index et les contraintes.
--
-- Conventions :
-- - Les noms de tables et de colonnes sont en snake_case.
-- - Toutes les tables ont des colonnes `created_at` et `updated_at` pour le suivi.
-- - Les clés primaires sont des `TEXT` pour correspondre aux UUID générés par l'application.
-- - Les configurations complexes (scripts, SVI) sont stockées en `JSONB` pour la flexibilité.
-- =============================================================================


-- =============================================================================
-- SECTION 1 : TYPES PERSONNALISÉS (ENUMS)
-- Utiliser des types ENUM garantit l'intégrité des données pour les champs
-- qui ont un ensemble limité de valeurs possibles.
-- =============================================================================

CREATE TYPE user_role AS ENUM ('Agent', 'Superviseur', 'Administrateur', 'SuperAdmin');
CREATE TYPE block_type AS ENUM ('group', 'label', 'text', 'input', 'email', 'phone', 'date', 'time', 'radio', 'checkbox', 'dropdown', 'button', 'web-view');
CREATE TYPE dialing_mode AS ENUM ('PREDICTIVE', 'PROGRESSIVE', 'MANUAL');
CREATE TYPE contact_status AS ENUM ('pending', 'called', 'qualified');
CREATE TYPE qualification_type AS ENUM ('positive', 'neutral', 'negative');
CREATE TYPE ivr_node_type AS ENUM ('start', 'menu', 'media', 'transfer', 'voicemail', 'hangup', 'calendar');
CREATE TYPE trunk_auth_type AS ENUM ('register', 'ip');
CREATE TYPE call_direction AS ENUM ('inbound', 'outbound');
-- Ajout pour le CDR complet
CREATE TYPE call_status_type AS ENUM ('ANSWERED', 'NO ANSWER', 'BUSY', 'FAILED', 'CONGESTION');

-- =============================================================================
-- SECTION 2 : TABLES PRINCIPALES
-- Définition des tables qui stockent les entités principales de l'application.
-- =============================================================================

-- Table pour stocker les sites géographiques ou logiques
CREATE TABLE sites (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE sites IS 'Stocke les différents sites physiques pour le routage des appels via Asterisk.';

-- Table des utilisateurs de l'application
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    login_id TEXT NOT NULL UNIQUE,
    extension VARCHAR(10) UNIQUE, -- AJOUT POUR ASTERISK
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT UNIQUE,
    "role" user_role NOT NULL DEFAULT 'Agent',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    password_hash TEXT NOT NULL, -- Stocker un hash du mot de passe, JAMAIS en clair
    site_id TEXT REFERENCES sites(id) ON DELETE SET NULL,
    mobile_number TEXT,
    use_mobile_as_station BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE users IS 'Contient tous les utilisateurs de la plateforme, leurs rôles et informations de connexion.';
COMMENT ON COLUMN users.extension IS 'Numéro d''extension SIP de l''agent, utilisé par Asterisk. Doit correspondre au login_id.';
COMMENT ON COLUMN users.mobile_number IS 'Numéro de mobile de l''agent pour la fonctionnalité "Connect to Phone".';
COMMENT ON COLUMN users.use_mobile_as_station IS 'Flag pour activer l''appel via le mobile de l''agent.';


CREATE INDEX idx_users_role ON users("role");
CREATE INDEX idx_users_site_id ON users(site_id);

-- Table des groupes d'utilisateurs (agents)
CREATE TABLE user_groups (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE user_groups IS 'Permet de regrouper des agents pour le routage ou le reporting.';

-- Table de liaison (many-to-many) entre utilisateurs et groupes
CREATE TABLE user_group_members (
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    group_id TEXT NOT NULL REFERENCES user_groups(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, group_id)
);
COMMENT ON TABLE user_group_members IS 'Table de jonction pour l''appartenance des utilisateurs aux groupes.';

-- Table des scripts d'agent
CREATE TABLE scripts (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    -- JSONB est utilisé pour stocker la structure complexe des pages et des blocs
    pages JSONB NOT NULL,
    start_page_id TEXT NOT NULL,
    background_color TEXT DEFAULT '#f1f5f9',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE scripts IS 'Stocke les scripts d''agents créés avec l''éditeur visuel.';

-- Table des groupes de qualifications
CREATE TABLE qualification_groups (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE qualification_groups IS 'Regroupe les qualifications pour les assigner aux campagnes.';

-- Table des qualifications d'appel
CREATE TABLE qualifications (
    id TEXT PRIMARY KEY,
    code TEXT NOT NULL UNIQUE,
    description TEXT NOT NULL,
    "type" qualification_type NOT NULL,
    group_id TEXT REFERENCES qualification_groups(id) ON DELETE SET NULL,
    is_standard BOOLEAN NOT NULL DEFAULT FALSE,
    parent_id TEXT REFERENCES qualifications(id) ON DELETE SET NULL, -- Pour la hiérarchie
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE qualifications IS 'Définit les statuts de fin d''appel pour le reporting et le recyclage.';
CREATE INDEX idx_qualifications_group_id ON qualifications(group_id);
CREATE INDEX idx_qualifications_parent_id ON qualifications(parent_id);


-- Table des campagnes d'appels sortants
CREATE TABLE campaigns (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    script_id TEXT REFERENCES scripts(id) ON DELETE SET NULL,
    qualification_group_id TEXT REFERENCES qualification_groups(id) ON DELETE SET NULL,
    caller_id TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    dialing_mode dialing_mode NOT NULL,
    -- Autres champs de configuration de la campagne
    wrap_up_time INTEGER NOT NULL DEFAULT 10,
    quota_rules JSONB DEFAULT '[]'::jsonb,
    filter_rules JSONB DEFAULT '[]'::jsonb,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    -- NOTE : Les règles complexes (quota, filtres, recyclage) peuvent être stockées en JSONB
    -- ou dans des tables dédiées pour des requêtes plus complexes.
);
COMMENT ON TABLE campaigns IS 'Configuration principale des campagnes d''appels sortants.';

-- Table de liaison (many-to-many) entre campagnes et agents
CREATE TABLE campaign_agents (
    campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    PRIMARY KEY (campaign_id, user_id)
);
COMMENT ON TABLE campaign_agents IS 'Table de jonction pour l''assignation des agents aux campagnes.';

-- Table des contacts à appeler
CREATE TABLE contacts (
    id TEXT PRIMARY KEY,
    campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    first_name TEXT,
    last_name TEXT,
    phone_number TEXT NOT NULL,
    postal_code TEXT,
    status contact_status NOT NULL DEFAULT 'pending',
    custom_fields JSONB, -- Pour stocker les champs additionnels du script
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE contacts IS 'Liste des contacts à appeler pour chaque campagne.';
CREATE INDEX idx_contacts_campaign_id_status ON contacts(campaign_id, status);
CREATE INDEX idx_contacts_phone_number ON contacts(phone_number);


-- Table des Trunks SIP
CREATE TABLE trunks (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    domain TEXT NOT NULL,
    login TEXT,
    password_encrypted TEXT, -- Doit être chiffré
    auth_type trunk_auth_type NOT NULL,
    register_string TEXT,
    dial_pattern TEXT NOT NULL,
    inbound_context TEXT NOT NULL,
    force_caller_id TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE trunks IS 'Configure les connexions aux opérateurs téléphoniques.';

-- Table des flux SVI (Serveur Vocal Interactif)
CREATE TABLE ivr_flows (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    nodes JSONB NOT NULL,
    connections JSONB NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE ivr_flows IS 'Stocke les SVI créés avec l''éditeur visuel.';

-- Table des numéros (SDA/DID)
CREATE TABLE dids (
    id TEXT PRIMARY KEY,
    "number" TEXT NOT NULL UNIQUE,
    description TEXT,
    trunk_id TEXT NOT NULL REFERENCES trunks(id) ON DELETE CASCADE,
    ivr_flow_id TEXT REFERENCES ivr_flows(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE dids IS 'Gère les numéros de téléphone entrants et leur routage.';

-- Table pour les fichiers audio
CREATE TABLE audio_files (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    file_name TEXT NOT NULL,
    duration INTEGER NOT NULL, -- en secondes
    size BIGINT NOT NULL, -- en octets
    upload_date TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE audio_files IS 'Bibliothèque de médias pour les SVI et musiques d''attente.';

-- =============================================================================
-- SECTION 3 : TABLES DE REPORTING ET DE SUIVI
-- Ces tables stockent les données générées par l'activité du centre d'appels.
-- =============================================================================

-- Table de l'historique des appels (CDR) - Version complète
CREATE TABLE call_history (
    id TEXT PRIMARY KEY,
    start_time TIMESTAMPTZ NOT NULL,
    answer_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ NOT NULL,
    duration INTEGER NOT NULL, -- Durée totale en secondes
    billable_duration INTEGER NOT NULL DEFAULT 0, -- Temps de parole en secondes
    direction call_direction NOT NULL,
    call_status call_status_type NOT NULL,
    source TEXT NOT NULL,
    destination TEXT NOT NULL,
    agent_id TEXT REFERENCES users(id) ON DELETE SET NULL,
    contact_id TEXT REFERENCES contacts(id) ON DELETE SET NULL,
    campaign_id TEXT REFERENCES campaigns(id) ON DELETE SET NULL,
    qualification_id TEXT REFERENCES qualifications(id) ON DELETE SET NULL,
    pbx_call_id TEXT, -- ID unique de l'appel du PBX (Yeastar/Asterisk)
    recording_path TEXT, -- Chemin vers le fichier d'enregistrement
    channel TEXT,
    destination_channel TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE call_history IS 'Journal détaillé (CDR) de tous les appels traités par le système.';
CREATE INDEX idx_call_history_start_time ON call_history(start_time);
CREATE INDEX idx_call_history_agent_id ON call_history(agent_id);
CREATE INDEX idx_call_history_campaign_id ON call_history(campaign_id);
CREATE INDEX idx_call_history_source ON call_history(source);
CREATE INDEX idx_call_history_destination ON call_history(destination);

-- Table des sessions des agents
CREATE TABLE agent_sessions (
    id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    login_time TIMESTAMPTZ NOT NULL,
    logout_time TIMESTAMPTZ
);
COMMENT ON TABLE agent_sessions IS 'Journal des connexions et déconnexions des agents.';
CREATE INDEX idx_agent_sessions_agent_id_login_time ON agent_sessions(agent_id, login_time);

-- Table des rappels personnels programmés par les agents
CREATE TABLE personal_callbacks (
    id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    contact_id TEXT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    scheduled_time TIMESTAMPTZ NOT NULL,
    notes TEXT,
    status TEXT NOT NULL DEFAULT 'pending', -- ex: pending, completed, cancelled
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE personal_callbacks IS 'Stocke les rappels manuels que les agents se programment.';
CREATE INDEX idx_personal_callbacks_agent_id_status ON personal_callbacks(agent_id, status);

-- Table pour l'historique des remarques sur une fiche contact
CREATE TABLE contact_notes (
    id TEXT PRIMARY KEY,
    contact_id TEXT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    agent_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    note TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE contact_notes IS 'Historique des remarques laissées par les agents sur une fiche contact.';
CREATE INDEX idx_contact_notes_contact_id ON contact_notes(contact_id);

-- =============================================================================
-- SECTION 4 : TABLES POUR LES PLANNIGS
-- =============================================================================

-- Types d'activités pour les plannings
CREATE TABLE activity_types (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    color TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE activity_types IS 'Définit les types d''activités planifiables (Appel, Pause, etc.).';

-- Événements du planning des agents
CREATE TABLE planning_events (
    id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    activity_id TEXT NOT NULL REFERENCES activity_types(id) ON DELETE CASCADE,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT check_dates CHECK (start_date < end_date)
);
COMMENT ON TABLE planning_events IS 'Stocke les événements du calendrier pour chaque agent.';
CREATE INDEX idx_planning_events_agent_id_dates ON planning_events(agent_id, start_date, end_date);


-- =============================================================================
-- SECTION 5 : FONCTIONS ET TRIGGERS
-- Fonctions utiles, par exemple pour mettre à jour automatiquement `updated_at`.
-- =============================================================================

CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer le trigger à toutes les tables qui ont un champ `updated_at`
DO $$
DECLARE
    t TEXT;
BEGIN
    FOR t IN 
        SELECT table_name 
        FROM information_schema.columns 
        WHERE column_name = 'updated_at' AND table_schema = 'public'
    LOOP
        EXECUTE format('CREATE TRIGGER set_timestamp
                        BEFORE UPDATE ON %I
                        FOR EACH ROW
                        EXECUTE FUNCTION trigger_set_timestamp();', t);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Fin du schéma
-- =============================================================================